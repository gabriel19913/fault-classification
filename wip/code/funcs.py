import pickle
import matplotlib.pyplot as plt
import numpy as np
import functools
import operator
from sklearn.preprocessing import MultiLabelBinarizer
import pandas as pd


def drange(start, stop, step):
    while start < stop:
        yield start
        start *= step


def open_data(file_name):
    # each data has the following key:
    # dict_keys(['fault_type', 'cycle_1', 'cycle_2', 'cycle_4', 'cycle_8', 'cycle_16',
    # 'cycle_32', 'fault_type_bin'])

    # Each cycle data has the following SNR
    # dict_keys(['I_pu', 'I_10db', 'I_20db', 'I_30db', 'I_40db', 'I_50db', 'I_60db',
    # 'I_70db', 'I_80db', 'I_90db', 'I_100db'])

    data_path = 'data/'
    with open(data_path + file_name, 'rb') as f:
        data = pickle.load(f)
    return data


def save_data(file_name, data):
    data_path = 'data/'
    with open(data_path + file_name, "wb") as f:
        pickle.dump(data, f)
    print(f'Data save in the hard drive with the name: {file_name}')


def plot_data(data):
    plt.plot(data)
    plt.show()


def add_noise(original_signal, snr):
    '''
    Equations:
    [1] SNR = Psignal / Pnoise
    [2] SNRdb = Psignal,db - Pnoise,db
    '''
    # Calculate signal power and convert to dB
    power_signal = original_signal ** 2
    sig_avg_watts = np.mean(power_signal)
    sig_avg_db = 10 * np.log10(sig_avg_watts)
    # Calculate noise according to [2] then convert to watts
    noise_avg_db = sig_avg_db - snr
    noise_avg_watts = 10 ** (noise_avg_db / 10)
    # Generate an sample of white noise
    mean_noise = 0
    noise = np.random.normal(mean_noise, np.sqrt(noise_avg_watts),
                             len(power_signal))
    # Noise up the original signal
    noise_signal = original_signal + noise
    return noise_signal


def apply_noise(data, key, string):
    """
    Apply noise into signal

    Parameters
    ----------
    data : list
        A list where each position has a dictionary with the fault type and
        the signal which the noise will be applied.
    key : str
        Key in the dictionary that represents the signal.
    string : str
        A string indicating if the signal is current (I) or voltage (V)

    Returns
    -------
    list
        A list with dictionaries. Each dictionary contains the fault type,
        and keys representind the signal + noise applied into the original
        signal with SNR varying as set in the `for` bellow, current
        between 10dB and 100dB.
    """
    final_data = []
    for _, v in enumerate(data):
        fault_dict = {'fault_type': v['fault_type'], key: v[key]}
        for snr in range(10, 110, 10):
            noise_a = add_noise(v[key][:, 0], snr).reshape(-1, 1)
            noise_b = add_noise(v[key][:, 1], snr).reshape(-1, 1)
            noise_c = add_noise(v[key][:, 2], snr).reshape(-1, 1)
            noise_signal = np.concatenate((noise_a, noise_b, noise_c), axis=1)
            fault_dict.update({f'{string}_{str(snr)}db': noise_signal})
        final_data.append(fault_dict)
    return final_data


def get_cycles(data, string):
    """
    Generates data from signal varying the quantity of cycles pos fault.

    Parameters
    ----------
    data : list
        A list with dictionaries generated by `apply_noise()` function.
    string : str
        String indicating if the signals are voltage ('V') or current ('I').

    Returns
    -------
    list
        A list with dictionaries:
            - keys for fault type and the quantity of cycles pos fault (1, 1/2,
            1/4, 1/8, 1/16, 1/32, 1/64)
            - Each key that indicates the variation of cycles also has a
            dictionary representing the variation of noise: 'pu' (no noise),
            '10db', '20db', '30db', '40db', '50db', '60db', '70db', '80db',
            '90db', '100db'
    """
    final_samples = []
    noise_str = ['pu', '10db', '20db', '30db', '40db', '50db', '60db', '70db',
                 '80db', '90db', '100db']
    keys = [f'{string}_' + i for i in noise_str]
    for data in data:
        append_dict = {}
        for n in drange(1, 65, 2):
            data_dict = {}
            for key in keys:
                size = int((data[key][64:, :].shape[0] - 64) / n + 64)
                signal = data[key][64:, :]
                signal_z = signal.sum(axis=1).reshape(-1, 1)
                final = np.concatenate((signal, signal_z), axis=1)
                data_dict[key] = final[:size, :]
            append_dict.update({'fault_type': data['fault_type'][0], 'cycle_' +
                                str(n): data_dict})
        final_samples.append(append_dict)
    return final_samples


def gen_key_list(data):
    key_list = [
        [key + '.' + k for k in data[0]['cycle_1'].keys()]
        for key in data[0].keys()
        if 'cycle' in key
    ]
    key_list = functools.reduce(operator.iconcat, key_list, [])
    return key_list


def convert_label(data):
    # A B C T >>> falta BCT: [0, 1, 1, 1]
    mlb = MultiLabelBinarizer()
    mlb.fit(['A', 'B', 'C', 'T'])
    for d in data:
        label = d['fault_type']
        out_vector = mlb.transform(np.array([label]))[0]
        d['fault_type_bin'] = out_vector
